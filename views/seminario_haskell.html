<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="../vendor/reveal.js/css/reveal.css">
		<link rel="stylesheet" href="../vendor/reveal.js/css/theme/black.css" id="theme">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="../assets/css/animation.css">

		<!-- Code syntax highlighting../vendor/reveal.js/ -->
		<link rel="stylesheet" href="../vendor/reveal.js/clib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../vendor/reveal.js/ccss/print/pdf.css' : '../vendor/reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-markdown><!-- Slide1: titulo -->
          <script type="text/template">
            #Tipos abstratos de dados
            ### Saulo Andrade, Phillipe Correia
            MATE81 - Topicos em fundamentos de programação
            Universidade Federal da Bahia - 2015.2
          </script>
				</section><!-- Slide1: titulo -->

        <section><!-- Slide2: introdução -->
          <section data-markdown>
            <script type="text/template">
              #Introdução
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##O que é um tipo abstrato de dados:
              - Listas, árvores, arrays...
              - Já definidas na linguagem...
              - ...ou derivadas explicitamente por tipos já existentes na linguagem
                - Árvores, arrays => listas
              - Tipos abstratos: derivação implícita
                - Palavra-chave: data / newtype
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Tipos abstratos de dados
              - Pilhas
              - Filas
              - Filas de prioridade
              - Conjuntos
              - Tabelas
              - Árvores binárias
              - Árvores AVL
              - Heaps
            </script>
  				</section>

        </section><!-- Slide2: introdução -->

        <section><!-- Slide_: Heaps -->

          <section data-markdown>
            <script type="text/template">
              #Heaps
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Definição de heap
              - Árvore de busca binária onde a chave do nó é menor do que a chave dos filhos deste nó (se houver)
                - Propriedade de ordem do heap
              - Raiz: valor mínimo da árvore
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ```haskell
              --     1
              --   /   \
              --  2     3
              -- / \   / \
              --4   6 5   7
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Operações em heaps
              - heapVazio: verifica se o heap está vazio.
              - menorHeap: retorna a menor chave do heap (raiz).
              - inserção: insere uma nova chave no heap atual. Atualiza o heap
              - remoção: remove uma chave do heap atual. Atualiza o heap
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Implementando heaps em Haskell
              - Implementação *leftist* (Okasaki [91])
                - Árvore binária.
                - Cada nó tem uma chave e um rank
                  - Chave: valor do nó.
                  - Rank: número de nós do menor caminho até um nó vazio.
                - A árvore *tende para a esquerda* (e se filia ao PT)
                - Caminho mais curto até uma folha: só andar para a direita.
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Implementando heaps em Haskell
```Haskell
module Heap(Heap, emptyHeap, heapEmpty, findHeap, insHeap,
	delHeap) where

emptyHeap :: (Ord a) => Heap a
heapEmpty :: (Ord a) => Heap a -> Bool
findHeap :: (Ord a) => Heap a -> a
insHeap :: (Ord a) => a -> Heap a -> Heap a
delHeap :: (Ord a) => Heap a -> Heap a
rank :: (Ord a) => Heap a -> Int
makeHP :: (Ord a) => a -> Heap a -> Heap a -> Heap a
merge :: (Ord a) => Heap a -> Heap a -> Heap a
```
            </script>
          </section>

					<section data-markdown>
            <script type="text/template">
              ##Implementando heaps em Haskell
```Haskell
emptyHeap = EmptyHP

heapEmpty EmptyHP = True
heapEmpty _ = False

findHeap EmptyHP = error "findHeap:empty Heap"
findHeap (HP x _ a b) = x
```
            </script>
          </section>

					<section data-markdown>
            <script type="text/template">
              ##Implementando heaps em Haskell
```Haskell
rank EmptyHP = 0
rank (HP _ r _ _) = r

makeHP x a b
  | rank a >= rank b = HP x (rank b + 1) a b
  | otherwise = HP x (rank a + 1) b a

merge h EmptyHP = h
merge EmptyHP h = h
merge h1@(HP x _ a1 b1) h2@(HP y _ a2 b2)
  | x <= y = makeHP x a1 (merge b1 h2)
  | otherwise = makeHP y a2 (merge h1 b2)
```
            </script>
          </section>

					<section data-markdown>
            <script type="text/template">
              ##Implementando heaps em Haskell
```Haskell
insHeap x h = merge (HP x 1 EmptyHP EmptyHP) h

delHeap EmptyHP = error "delHeap:empty heap"
delHeap (HP x _ a b) = merge a b
```
            </script>
          </section>

					<section data-markdown>
            <script type="text/template">
							##Complexidade da implementação
							- heapVazio, menorHeap: **O(1)**
								- Verifica a raiz do heap
							- inserção, remoção: **O(log n)**
								- Merge da espinha direita de duas árvores leftist
            </script>
          </section>

        </section><!-- Slide_: Heaps -->

				<section style="text-align: left;">
					<h1>THE END</h1>
					<p>
						- <a href="http://slides.com">Try the online editor</a> <br>
						- <a href="https://github.com/hakimel/reveal.js">Source code &amp; documentation</a>
					</p>
				</section>

			</div>

		</div>

		<script src="../vendor/reveal.js/lib/js/head.min.js"></script>
		<script src="../vendor/reveal.js/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
                // Parallax background image
                        parallaxBackgroundImage: "https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg",

                // Parallax background size
                parallaxBackgroundSize: '2100px 900px', // CSS syntax, e.g. "2100px 900px" - currently only pixels are supported (don't use % or auto)

                // Number of pixels to move the parallax background per slide
                // - Calculated automatically unless specified
                // - Set to 0 to disable movement along an axis
                parallaxBackgroundHorizontal: 200,
                parallaxBackgroundVertical: 50,

				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: '../vendor/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../vendor/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../vendor/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../vendor/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../vendor/reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: '../vendor/reveal.js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
