<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>reveal.js – The HTML Presentation Framework</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Hakim El Hattab">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="../vendor/reveal.js/css/reveal.css">
	<link rel="stylesheet" href="../vendor/reveal.js/css/theme/simple.css" id="theme">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="../assets/css/animation.css">

	<!-- Code syntax highlighting../vendor/reveal.js/ -->
	<link rel="stylesheet" href="../vendor/reveal.js/clib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
	var link = document.createElement( 'link' );
	link.rel = 'stylesheet';
	link.type = 'text/css';
	link.href = window.location.search.match( /print-pdf/gi ) ? '../vendor/reveal.js/ccss/print/pdf.css' : '../vendor/reveal.js/css/print/paper.css';
	document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section data-markdown><!-- Slide1: titulo -->
				<script type="text/template">
					#Tipos abstratos de dados
					### Saulo Andrade, Phillipe Correia
					MATE81 - Topicos em fundamentos de programação
					Universidade Federal da Bahia - 2015.2
				</script>
			</section><!-- Slide1: titulo -->

			<section><!-- Slide2: introdução -->
				<section data-markdown>
					<script type="text/template">
						#Introdução
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##O que é um tipo abstrato de dados:
						- Listas, árvores, arrays...
						- Já definidas na linguagem...
						- ...ou derivadas explicitamente por tipos já existentes na linguagem
						- Árvores, arrays => listas
						- Tipos abstratos: derivação implícita
						- Palavra-chave: data / newtype
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Tipos abstratos de dados
						- Pilhas
						- Filas
						- Filas de prioridade
						- Conjuntos
						- Tabelas
						- Árvores binárias
						- Árvores AVL
						- Heaps
					</script>
				</section>

			</section><!-- Slide2: introdução -->

			<section><!-- Slide3: pilhas-->

				<section data-markdown>
					<script type="text/template">
						#Pilhas
					</script>
				</section>

			</section><!-- Slide3: pilhas-->

			<section><!-- Slide4: filas-->

				<section data-markdown>
					<script type="text/template">
						#Filas
					</script>
				</section>

			</section><!-- Slide4: filas-->

			<section><!-- Slide5: filas de prioridade-->

				<section data-markdown>
					<script type="text/template">
						#Filas de prioridade
					</script>
				</section>

			</section><!-- Slide5: filas de prioridade-->

			<section><!-- Slide6: conjuntos-->

				<section data-markdown>
					<script type="text/template">
						#Conjuntos
					</script>
				</section>

			</section><!-- Slide6: conjuntos-->

			<section><!-- Slide7: tabelas-->

				<section data-markdown>
					<script type="text/template">
						#Tabelas
					</script>
				</section>

			</section><!-- Slide7: tabelas-->

			<section><!-- Slide8: arvore busca binaria -->
				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="http://cdn.makeagif.com/media/7-02-2015/m2cI7J.gif"-->
						#Árvores de busca binária
					</script>
				</section>
			</section><!-- Slide8: arvore busca binaria -->

			<section><!-- Slide9: Heaps -->

				<section data-markdown>
					<script type="text/template">
						#Heaps
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Definição de heap
						- Árvore de busca binária onde a chave do nó é menor do que a chave dos filhos deste nó (se houver)
						- Propriedade de ordem do heap
						- Raiz: valor mínimo da árvore
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						```haskell
						--     1
						--   /   \
						--  2     3
						-- / \   / \
						--4   6 5   7
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Operações em heaps
						- Inserção: insere uma nova chave no heap atual. Atualiza o heap.
						- Remoção: remove uma chave do heap atual. Atualiza o heap.
						- HeapVazio: verifica se o heap está vazio.
						- MenorHeap: retorna a menor chave do heap (raiz).
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando heaps em Haskell
						- Implementação *leftist* (Okasaki [91])
						- Árvore binária.
						- Cada nó tem uma chave e um rank
						- Chave: valor do nó.
						- Rank: número de nós do menor caminho até um nó vazio.
						- A árvore *tende para a esquerda* (e se filia ao PT)
						- Caminho mais curto até uma folha: só andar para a direita.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando heaps em Haskell
						```Haskell
						module Heap(Heap, emptyHeap, heapEmpty, findHeap, insHeap,
						delHeap) where

						emptyHeap :: (Ord a) => Heap a
						heapEmpty :: (Ord a) => Heap a -> Bool
						findHeap :: (Ord a) => Heap a -> a
						insHeap :: (Ord a) => a -> Heap a -> Heap a
						delHeap :: (Ord a) => Heap a -> Heap a
						rank :: (Ord a) => Heap a -> Int
						makeHP :: (Ord a) => a -> Heap a -> Heap a -> Heap a
						merge :: (Ord a) => Heap a -> Heap a -> Heap a
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando heaps em Haskell
						```Haskell
						emptyHeap = EmptyHP

						heapEmpty EmptyHP = True
						heapEmpty _ = False

						findHeap EmptyHP = error "findHeap:empty Heap"
						findHeap (HP x _ a b) = x
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando heaps em Haskell
						```Haskell
						rank EmptyHP = 0
						rank (HP _ r _ _) = r

						makeHP x a b
						| rank a >= rank b = HP x (rank b + 1) a b
						| otherwise = HP x (rank a + 1) b a

						merge h EmptyHP = h
						merge EmptyHP h = h
						merge h1@(HP x _ a1 b1) h2@(HP y _ a2 b2)
						| x <= y = makeHP x a1 (merge b1 h2)
						| otherwise = makeHP y a2 (merge h1 b2)
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando heaps em Haskell
						```Haskell
						insHeap x h = merge (HP x 1 EmptyHP EmptyHP) h

						delHeap EmptyHP = error "delHeap:empty heap"
						delHeap (HP x _ a b) = merge a b
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Complexidade da implementação
						- heapVazio, menorHeap: **O(1)**
						- Verifica a raiz do heap
						- inserção, remoção: **O(log n)**
						- Merge da espinha direita de duas árvores leftist
					</script>
				</section>

			</section><!-- Slide9: Heaps -->

			<section><!-- Slide10: Árvores AVL -->

				<section data-markdown>
					<script type="text/template">
						#Árvore AVL
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Definição de Árvore AVL
						- Árvore de busca binária com condição de balanceamento
						- Altura das subárvores não pode ser maior do que 1
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						```haskell
						-- Isto é uma árvore AVL
						--     4
						--   /   \
						--  2     6
						--   \   / \
						--    3 5   8
						--           \
						--            9
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						```haskell
						-- Isto é uma árvore, mas não é AVL
						--        6
						--      /   \
						--     3     7
						--    / \
						--   2   4
						--  /
						-- 1
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Operações em árvores AVL
						- Inserção: Insere um novo nó na árvore. Rebalanceia a árvore se necessário.
						- Remoção: Remove um nó existente da árvore. Rebalanceia a árvore se necessário.
						- Rotação: Rotaciona uma árvore. Usada para rebalancear a árvore.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="http://big.assets.huffingtonpost.com/spinning_the_wheel_by_leafman813-d6uhbh6.gif"-->
						#Rodando uma árvore AVL
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Rodando uma árvore AVL
						- Rotação à direita (Right Rotation)
						- Rotação à esquerda (Left Rotation)
						- Rotação dupla à direita (Left-Right Double Rotation)
						- Rotação dupla à esquerda (Right-Left Double Rotation)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando Árvores AVL em Haskell
						```Haskell
						module AVLTree(AVLTree,emptyAVL,addAVL) where
						rotateLeft,rotateRight ::
						(Ord a,Show a) => AVLTree a -> AVLTree a
						dRotateLeftRight , dRotateRightLeft ::
						(Ord a,Show a) => AVLTree a -> AVLTree a

						data AVLTree a = EmptyAVL | NodeAVL a (AVLTree a) (AVLTree a)
						deriving (Eq, Ord, Show)

						emptyAVL = EmptyAVL
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando Árvores AVL em Haskell
						```Haskell
						rotateLeft EmptyAVL = EmptyAVL
						rotateLeft (NodeAVL v (NodeAVL lv lflf lfrt) rt)
						= NodeAVL lv lflf (NodeAVL v lfrt rt)

						rotateRight EmptyAVL  = EmptyAVL
						rotateRight (NodeAVL v lf (NodeAVL rv rtlf rtrt))
						= NodeAVL rv (NodeAVL v lf rtlf) rtrt
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando Árvores AVL em Haskell
						```Haskell
						dRotateRightLeft
						(NodeAVL v lf (NodeAVL rv (NodeAVL rtlv rtlflf rtlfrt) rtrt))
						= NodeAVL rtlv
						((NodeAVL v lf rtlflf) NodeAVL rv rtlfrt rtrt)

						dRotateLeftRight
						(NodeAVL v (NodeAVL lv lflf (NodeAVL lfrv lfrtlf lfrtrt)) rt)
						= NodeAVL lfrv
						(NodeAVL lv lflf lfrtlf) (NodeAVL v lfrtrt rt)
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando Árvores AVL em Haskell
						```Haskell
						height EmptyAVL  = 0
						height (NodeAVL _ lf rt) = 1 + max (height lf) (height rt)
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando Árvores AVL em Haskell
						```Haskell
						addAVL i EmptyAVL= NodeAVL i EmptyAVL EmptyAVL
						addAVL i (NodeAVL v lf rt)
						| i < v = let
						newlf@(NodeAVL newlfv _ _)  = addAVL i lf
						in
						if ((height newlf - height rt) == 2)
						then if i < newlfv
						then rotateLeft (NodeAVL v newlf rt)
						else dRotateLeftRight (NodeAVL v newlf rt)
						else (NodeAVL v newlf rt)
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando Árvores AVL em Haskell
						```Haskell
						| otherwise = let
						newrt@(NodeAVL newrtv _ _)  = addAVL i rt
						in
						if ((height newrt - height lf) == 2)
						then if i > newrtv
						then rotateRight (NodeAVL v lf newrt)
						else dRotateRightLeft (NodeAVL v lf newrt)
						else (NodeAVL v lf newrt)
						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Complexidade da implementação
						- Inserção, Remoção, Busca: O(log n)
						- Rotação: O(1)
					</script>
				</section>

			</section><!-- Slide10: Árvores AVL -->

			<section><!-- Slide11: Fim-->
				<h1>OBRIGADO</h1>
			</section><!-- Slide11: Fim-->

		</div>

	</div>

	<script src="../vendor/reveal.js/lib/js/head.min.js"></script>
	<script src="../vendor/reveal.js/js/reveal.js"></script>

	<script>

	// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
		// Parallax background image
		//parallaxBackgroundImage: "#ffffff",

		// Parallax background size
		//parallaxBackgroundSize: '2100px 900px', // CSS syntax, e.g. "2100px 900px" - currently only pixels are supported (don't use % or auto)

		// Number of pixels to move the parallax background per slide
		// - Calculated automatically unless specified
		// - Set to 0 to disable movement along an axis
		//parallaxBackgroundHorizontal: 0,
		//parallaxBackgroundVertical: 0,

		controls: true,
		progress: true,
		history: true,
		center: true,

		transition: 'convex', // none/fade/slide/convex/concave/zoom

		// Optional reveal.js plugins
		dependencies: [
			{ src: '../vendor/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: '../vendor/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: '../vendor/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: '../vendor/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: '../vendor/reveal.js/plugin/zoom-js/zoom.js', async: true },
			{ src: '../vendor/reveal.js/plugin/notes/notes.js', async: true }
		]
	});

	</script>

</body>
</html>
