<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>TIPOS ABSTRATOS DE DADOS EM HASKELL - reveal.js – The HTML Presentation Framework</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Hakim El Hattab">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="../vendor/reveal.js/css/reveal.css">
	<link rel="stylesheet" href="../vendor/reveal.js/css/theme/simple.css" id="theme">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="../assets/css/animation.css">

	<!-- Code syntax highlighting../vendor/reveal.js/ -->
	<link rel="stylesheet" href="../vendor/reveal.js/clib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
	var link = document.createElement( 'link' );
	link.rel = 'stylesheet';
	link.type = 'text/css';
	link.href = window.location.search.match( /print-pdf/gi ) ? '../vendor/reveal.js/ccss/print/pdf.css' : '../vendor/reveal.js/css/print/paper.css';
	document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section data-markdown><!-- Slide1: titulo -->
				<script type="text/template">
					#Tipos abstratos de dados
					### Saulo Andrade, Philippe Correia
					MATE81 - Topicos em fundamentos de programação
					Universidade Federal da Bahia - 2015.2
				</script>
			</section><!-- Slide1: titulo -->

			<section><!-- Slide2: introdução -->
				<section data-markdown>
					<script type="text/template">
						#Introdução
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##O que é um tipo abstrato de dados:
						- Definido como um modelo matemático por meio de um par (v, o) em que:
							- v: conjunto de valores
							- o: conjunto de operações sobre esses valores
						- Ex.: Conjunto dos números reais
							- v: R
							- o: {+, -, *, /, =, >, >=, <, <=}
						- Palavra-chave: data / newtype
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Tipos abstratos de dados
						- Pilhas
						- Filas
						- Filas de prioridade
						- Conjuntos
						- Tabelas
						- Heaps
						- Árvores binárias
						- Árvores AVL
					</script>
				</section>

			</section><!-- Slide2: introdução -->

			<section><!-- Slide3: sobre modulos -->
				<section data-markdown>
					<script type="text/template">
						#Introdução a módulos em haskell
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="../assets/exemplo_Module.png"-->
					</script>
				</section>

			</section><!-- Slide3: sobre modulos -->

			<section><!-- Slide4: pilhas-->

				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="http://forgifs.com/gallery/d/242971-2/Baby-stacking-blocks-ragequit.gif"-->
						#Pilhas (LIFO)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![Imagem Pilha](../assets/exemplo_pilha.png)
					</script>
				</section>

			</section><!-- Slide4: pilhas-->

			<section><!-- Slide5: filas-->

				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="http://forgifs.com/gallery/d/228131-2/Waiting-in-lines-queue.gif"-->
						#Filas (FIFO)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![Imagem Fila](../assets/Exemplo_fila.png)
					</script>
				</section>

			</section><!-- Slide5: filas-->

			<section><!-- Slide6: filas de prioridade-->

				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="http://assimcomovoce.blogfolha.uol.com.br/files/2012/06/mercado.jpg"-->
						#Filas de prioridade
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando filas de prioridade em Haskell
						- Implementação em listas
						- Implementação em heap
					</script>
				</section>

			</section><!-- Slide6: filas de prioridade-->

			<section><!-- Slide7: conjuntos-->

				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="http://html.rincondelvago.com/000425604.png"-->
						#Conjuntos
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Definição de conjuntos
						- Coleção de itens distintos
						- Não há elementos repetidos
						- Tamanho do conjunto: quantos elementos distintos existem no conjunto
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Operações em conjuntos
						- Pertença: Verifica se um dado elemento pertence a um determinado conjunto
						- Inserção: Insere um novo elemento em um conjunto (se não existir).
						- Remoção: Remove um elemento de um conjunto (se existir).
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando conjuntos em Haskell
						- Várias maneiras de implementar
						- Algumas mais eficientes, outras não.
						- Qual operação será priorizada?
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando conjuntos em Haskell
						- Listas
							- Não ordenada, sem duplicatas
							- Não ordenada, com duplicatas
							- Ordenada, sem duplicatas
						- Árvores
						- Vetor de bits
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Conjuntos com listas
						- Não ordenada, com duplicatas
							- Inserção simples:
								- Só inserir na lista.
								- Tempo constante. **O(1).**
							- Pertença e remoção complicadas:
								- Pode precisar varrer toda a lista.
								- Precisa remover todas as instâncias do elemento na lista.
								- A lista pode ser maior do que o conjunto.
								- Lista de tamanho k comporta n elementos tq. k >= n.
								- Tempo linear no tamanho da lista. **O(k).**
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Conjuntos com listas
						- Não ordenada, sem duplicatas
							- Tamanho da lista = Tamanho do conjunto.
							- Remoção simples:
								- Só precisa remover uma única instância do elemento.
							- Inserção complicada:
								- Pode precisar varrer toda a lista.
								- Precisa verificar se o elemento já está na lista.
							- Tempo linear no tamanho do conjunto. **O(n).**
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Conjuntos com listas
						- Ordenada, sem duplicatas
							- Deriving Ord
							- Pertença e remoção simples:
								- Pode encerrar mais cedo em relação a implementação anterior
							- Tempo linear no tamanho do conjunto. **O(n)**
							- Mesmo a lista estando ordenada, a melhora não é tao grande assim.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						####Comparando a complexidade das implementações
---------------------------------------------
Implementacao | Pertença | Inserção | Remoção
--------------|----------|----------|--------
lista nao ordenada com duplicatas | O(k) | O(1) | O(k)
lista nao ordenada sem duplicatas | O(n) | O(n) | O(n)
lista ordenada sem duplicatas | O(n) | O(n) | O(n)
árvores | O(log n) | O(log n) | O(log n)
vetor de bits | ? | ? | ?
---------------------------------------
							n: #elementos do conjunto. k: #elementos da lista. k >= n.
					</script>
				</section>

			</section><!-- Slide7: conjuntos-->

			<section><!-- Slide8: tabelas-->

				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="https://media.giphy.com/media/11PoCVGkSg46Iw/giphy.gif"-->
						#Tabelas
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Definição de tabelas
						- Permite armazenar e recuperar valores conforme índices.
						- Planilha de Excel
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Operações com tabelas
						- Gerar Tabela: Gera uma nova tabela a partir de uma lista de pares (índice, valor).
						- Seleção: Recupera valores da tabela.
						- Atualização: Atualiza valores da tabela.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando tabelas em Haskell
						- Implementação via função
						- Implementação via listas
						- Implementação via arrays
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando tabelas com funções
						- Aproveitando o poder de Haskell.
						- Inserir um elemento em um índice -> Criar nova função para tal elemento.
							- Aplica fold
						- Custo depende de quando efetuar a operação de atualização.
							- Quanto mais tarde, melhor
							- Seleção linear no pior caso.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando tabelas com listas
						- Lista de pares (índice, valor)
							- Lista de associação
						- Representação ineficiente
							- Seleção e atualização lineares no pior caso, em relação ao número de entradas da tabela.
							- Mesmo se ordenar os índices, o tempo de acesso continua linear.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando tabelas com arrays
						- Deriving Ix
						- Não permite inserir ou atualizar valores fora dos índices da tabela.
						- Gerar Tabela agora determina os limites da tabela.
						- Seleção gera erro de sistema
						- Complexidade depende da implementação do array.
							- **O(1)** no melhor caso. Restringe atualização.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando tabelas com árvores
						- Usar árvores de busca binária ou heap.
						- Cada nó representa um par (índice, valor)
						- Complexidade: **O(log n)**
					</script>
				</section>

			</section><!-- Slide8: tabelas-->

			<section><!-- Slide9: Heaps -->

				<section data-markdown>
					<script type="text/template">
						<!-- .slide: data-background="http://thinkfuture.com/wp-content/uploads/2014/03/heaps.jpg"-->
						#Heaps
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Definição de heap
						- Árvore de busca binária onde a chave do nó é menor do que a chave dos filhos deste nó (se houver)
						- Propriedade de ordem do heap
						- Raiz: valor mínimo da árvore
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![Imagem Heap](../assets/haskell_exemploHeap.jpg)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![Imagem Nao Heap](../assets/haskell_exemploNaoHeap.jpg)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Operações em heaps
						- Inserção: insere uma nova chave no heap atual. Atualiza o heap.
						- Remoção: remove uma chave do heap atual. Atualiza o heap.
						- HeapVazio: verifica se o heap está vazio.
						- MenorHeap: retorna a menor chave do heap (raiz).
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Implementando heaps em Haskell
						- Implementação *leftist* (Okasaki [91])
						- Árvore binária.
						- Cada nó tem uma chave e um rank
						- Chave: valor do nó.
						- Rank: número de nós do menor caminho até um nó vazio.
						- A árvore *tende para a esquerda.*
						- Caminho mais curto até uma folha: só andar para a direita.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						##Complexidade da implementação
						- heapVazio, menorHeap: **O(1)**
							- Verifica a raiz do heap
						- inserção, remoção: **O(log n)**
							- Merge da espinha direita de duas árvores leftist
					</script>
				</section>

			</section><!-- Slide9: Heaps -->

			<section><!-- Slide10: Fim-->
				<h1>OBRIGADO</h1>
			</section><!-- Slide10: Fim-->

		</div>

	</div>

	<script src="../vendor/reveal.js/lib/js/head.min.js"></script>
	<script src="../vendor/reveal.js/js/reveal.js"></script>

	<script>

	// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
		// Parallax background image
		//parallaxBackgroundImage: "#ffffff",

		// Parallax background size
		//parallaxBackgroundSize: '2100px 900px', // CSS syntax, e.g. "2100px 900px" - currently only pixels are supported (don't use % or auto)

		// Number of pixels to move the parallax background per slide
		// - Calculated automatically unless specified
		// - Set to 0 to disable movement along an axis
		//parallaxBackgroundHorizontal: 0,
		//parallaxBackgroundVertical: 0,

		controls: true,
		progress: true,
		history: true,
		center: true,

		transition: 'zoom', // none/fade/slide/convex/concave/zoom

		// Optional reveal.js plugins
		dependencies: [
			{ src: '../vendor/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: '../vendor/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: '../vendor/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: '../vendor/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: '../vendor/reveal.js/plugin/zoom-js/zoom.js', async: true },
			{ src: '../vendor/reveal.js/plugin/notes/notes.js', async: true }
		]
	});

	</script>

</body>
</html>
